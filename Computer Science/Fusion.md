[Monadic Fold, Monadic Build, Monadic Short Cut Fusion](https://cs.appstate.edu/~johannp/fusion.pdf)
* foldr/build fusion to eliminate intermediate data structures, but in a general monadic context

**Figure 2** `fold`/`build` fusion for a generic inductive data type:

```haskell
newtype Mu f = In {unIn :: f (Mu f)}

fold :: Functor f => (f a -> a) -> Mu f -> a
fold h (In k) = h (fmap (fold h) k)

build :: Functor f => (forall a. (f a -> a) -> c -> a) -> c -> Mu f
build g = g In

-- fold k . build g = g k
```

**Figure 3** `mfold`/`mbuild` combinators and rule:

```haskell
mfold :: (Functor f, Monad m, Dist f m) => (f a -> m a) -> Mu f -> m a
mfold h = fold (\xs -> delta xs >>= h)

mbuild :: (Functor f, Monad m) => (forall a. (f a -> m a) -> c -> m a) -> c -> m (Mu f)
mbuild g = g (return . In)

-- mbuild g c >>= mfold h = g h c
```

> "Unlike the monadic fusion rule of [11], which eliminates the data structure but leaves the monadic context in which it is situated intact, the rule in Figure 3 eliminates both the entire intermediate data structure and its entire monadic context. The correctness of this rule is the main result of this paper." p. 5

**Figure 4** `mfoldl`/`mbuildl` combinators and rule:

```haskell
mfoldl :: Monad m => (Int -> a -> m a) -> m a -> [Int] -> m a
mfoldl c n = foldr (\i y -> do { v <- y;
                                 c i v }) n

mbuildl :: (forall a. (Int -> a -> m a) -> m a -> c -> m a) -> c -> m [Int]
mbuildl g = g (\x y -> return (x:y))
              (return [])

-- mbuildl g k >>= mfoldl c n = g c n k
```

## `fold` vs `mfold`

> "Both of these combinators recursively act on the subterms of a term to produce results which are of monadic type. The standard fold combinator then uses an algebra of type `f (m a) -> m a` to combine these results into an overall result for the original term. The carrier of the standard `fold`â€™s algebra is `m a`, which means that the programmer must specify how the monadic contexts generated by the recursive calls will be propagated to the original term. By contrast, the `mfold` combinator is used together with a distributivity law, whose role is precisely to achieve this propagation. The role of the monadic algebra of type `f a -> m a` is thus to describe how *pure* values can be combined and/or generate new effects." p. 6
